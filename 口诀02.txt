ACID
A:Atomicity 原子性
C:Consistency 一致性
I:Isolation 隔离性
D:Durability 持久性
-----------------------------------------------------------------
ACID 原子 一致 隔离 持久
院子（进了）野猪，古力（赶紧从）柱（子）（解开系着的）狗，（好让狗逃跑）
-----------------------------------------------------------------

Lock

private Lock lock = new ReentrantLock();

//需要参与同步的方法
private void method(Thread thread) {
	lock.lock();
	try {
		System.out.println("线程名" + thread.getName() + "获得了锁");
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		System.out.println("线程名" + thread.getName() + "释放了锁");
		lock.unlock();
	}
}

private void method(Thread thread) {
	if (lock.tryLock()) {
		try {
			System.out.println("线程名" + thread.getName() + "获得了锁");
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			System.out.println("线程名" + thread.getName() + "释放了锁");
			lock.unlock();
		}
	} else {
		System.out.println("我是" + Thread.currentThread().getName() + "有人占着锁，我就不要啦");
	}
}
-----------------------------------------------------------------
Lock lock = new ReentrantLock(); method lock.lock(); try catch finally lock.unlock(); if (lock.tryLock())
骑（着）鹿（的）女（子），（被一群）绿（色）鹌鹑（挡了）路，（拿着）花（的）落落（用手中的花引开了他们），（突然），（落落的）左脚（中了）火弩（的箭），（落落）按（下手）雷，（准备还击），（这时），一菲（从山坡上滚下）车碌
-----------------------------------------------------------------

在ThreadPoolExecutor类中提供了四个构造方法：
public class ThreadPoolExecutor extends AbstractExecutorService {
    .....
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
    ...
}
从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。
-----------------------------------------------------------------
以下为对第四个构造器的记忆
石榴铺，（铺口前摆放着一只）电子狗，（有顾客光临），（是）（叼着）烟（的）郭富城，（他的）袜（子）（镶嵌着）宝石，（跟随着他的）狼，（嘴里叼着）企鹅头。（郭富城找了一张台坐了下来），台油（腻）（带）泥，（郭富城一拨），（桌子上的一些）玻璃（飞到了旁边）（吴）奇隆（的身上），（吴奇隆生气得）撕烂（了）（郭富城的）裤（子），（拿着）绿遮（做武器的）（谭）耀汉（立马上前制止）
-----------------------------------------------------------------

Callable

1:
FutureTask<Integer> future = new FutureTask<Integer>(callable);
new Thread(future).start();
future.get();

2:
ExecutorService threadPool = Executors.newSingleThreadExecutor();
Future<Integer> future = threadPool.submit(new Callable<Integer>() {
	public Integer call() throws Exception {
		return new Random().nextInt(100);
	}
});
future.get();

3:
ExecutorService threadPool = Executors.newCachedThreadPool();
CompletionService<Integer> cs = new ExecutorCompletionService<Integer>(threadPool);
for(int i = 1; i < 5; i++) {
	final int taskID = i;
	cs.submit(new Callable<Integer>() {
		public Integer call() throws Exception {
			return taskID;
		}
	});
}
// 可能做一些事情
for(int i = 1; i < 5; i++) {
	try {
		System.out.println(cs.take().get());
	} catch (InterruptedException e) {
		e.printStackTrace();
	} catch (ExecutionException e) {
		e.printStackTrace();
	}
}

4:
ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                 new ArrayBlockingQueue<Runnable>(5));
executor.execute(myTask);
executor.shutdown();

5:
Callable<Integer> callable = new Callable<Integer>() {
	public Integer call() throws Exception {
		return new Random().nextInt(100);
	}
};
-----------------------------------------------------------------
Callable FutureTask ExecutorService CompletionService ThreadPoolExecutor Callable
烤炉（上烤着面）包，（还有）肥猪头，医生（居然）（把）蠄蜍（也放上去），石兰（则）铺鱼（在炉上烤），（还把）可乐（倒进）煲（里），（放上炉煲）
	FutureTask<Integer> future = new FutureTask<Integer>(callable);
	new Thread(future).start();
	future.get();
	（在有着）肥猪头（的肥猪）（身上撒满）火药，（从）狗嘴（中接过）咖喱煲，（然后倒咖喱在猪身上），（再撒一些）生蒜。（最后划着）火柴，烧（猪的）蛋（蛋）（从而点燃整只猪），（一会儿猪熟了），（撕一只）肥猪脚（来吃）
	ExecutorService threadPool = Executors.newSingleThreadExecutor();
	Future<Integer> future = threadPool.submit(new Callable<Integer>() {
		public Integer call() throws Exception {
			return new Random().nextInt(100);
		}
	});
	future.get();
	医生（坐）的士（到）桥头，（在车上拉了一坨）屎，（扔到车窗外的）牛屎（堆里），（有人用）水瓢（把屎弄到）书包（里），（里面有）泥，（外面再用）海报（包着）
	ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
	CompletionService<Integer> cs = new ExecutorCompletionService<Integer>(cachedThreadPool);
	for(int i = 1; i < 5; i++) {
		final int taskID = i;
		cs.submit(new Callable<Integer>() {
			public Integer call() throws Exception {
				return taskID;
			}
		});
	}
	// 可能做一些事情
	for(int i = 1; i < 5; i++) {
		try {
			System.out.println(cs.take().get());
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
	}
	蠄蜍（快要被着）火（的）叶（子）（烧到了），（某人用）尿液（浇熄了火），（并且）kʌm扇（隔绝空气），（但又发现旁边还有）火药，（于是立马用）戒指（撬开）水壶，（意图浇湿火药），（但）（不知）火舞（出来阻挠），沙（暴）（从她的）扇（子）（出来），（某人唯有用）书包（挡）面，口（咬着）（面）包，（跑到一座）石（头）山（后），（躲在）台脚（旁边）
-----------------------------------------------------------------