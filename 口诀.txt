AOP原理：
-----------------------------------------------------------------
代理实例，loader，父类，handler，method，调用，代理对象，参数
【大理石林（里），榴弹，（装在）裤里，憨豆，梅（威）瑟，（穿着）貂绒，（用）大理对象，撑船（逃跑）】

enhancer，设父（设置父类），回调（设置回调），创造（创建代理对象），调父（invokeSuper）
【耀汉，切肤，（痛得）喂（地叫）跳（起来），（跳去）床灶，脱裤】
-----------------------------------------------------------------

这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
-----------------------------------------------------------------
运行 动态 类 方法 位置
-----------------------------------------------------------------

八种排序方法
-----------------------------------------------------------------
直接插入排序，希尔排序，冒泡排序，快速排序，直接选择排序，堆排序，归并排序，基数排序
分别取第一个字
直希冒快直堆归基
蒸气（上的飘着的）毛（着）火，（蒸气源头的）（树）枝堆（下有）鬼机（闹鬼飞机）
-----------------------------------------------------------------

泛型
-----------------------------------------------------------------
泛型标志<T>在类名的后面或方法返回类型的前面
类后返前
你好犯贱
-----------------------------------------------------------------

RMI
-----------------------------------------------------------------

-----------------------------------------------------------------

线程
-----------------------------------------------------------------
Thread套Runnable（必须用new Thread()套住实现Runnable接口的类，此类才能start()）
仙桃（被）龙拿（了）
-----------------------------------------------------------------

麻将
-----------------------------------------------------------------
打麻将时，碰就扔一个子，干就摸一个子
碰人干摸
碰（撞别）人（的）肛（门里的）膜
-----------------------------------------------------------------

Redis的键值可以使用5种数据类型：字符串(Strings)，散列表(hashes)，列表(Lists)，集合(Sets 求交集、并集)，有序集合(Sorted Sets)
-----------------------------------------------------------------
Redis 字 散 列 集 序
绿地（谐Redis）（上有一把）（带）字（的）伞（谐散），裂（谐列）（了），（看上去是被旁边一个）执（谐集）锥（谐序）（的人弄裂的）
-----------------------------------------------------------------

volatile在多线程环境下，可以做到：1、防止重排序，2、实现可见性，3、但不能保证原子性
-----------------------------------------------------------------
volatile防重，可见，不原
锅（谐volatile）（里）放葱，荷肩（荷叶包着的猪肩），（还有）白盐（谐不原）
-----------------------------------------------------------------

Java变量命名规范
-----------------------------------------------------------------
首字母是英文字母、$和下划线，由英文字母、数字和下划线组成。（备注：可以为英文字母，也可以是汉字）
首字$下，字数下组
手指撕（$）虾，（用手）指数虾（和红）枣
-----------------------------------------------------------------

英菲尼迪：日产，讴歌：本田
-----------------------------------------------------------------
英日歌本
鹰（飞在）日（下）（位置：）哥（谐歌）本（哈根）
-----------------------------------------------------------------

-zxvf
-----------------------------------------------------------------
纸箱（是从）潍坊（寄过来的）
-----------------------------------------------------------------

case when then else end
-----------------------------------------------------------------
骑士（谐case）玩（谐when）蛋（谐then）L（谐else）籺（谐end）
-----------------------------------------------------------------

springMVC常用标签
@Controller @RequestMapping @Resource @Autowired @ModelAttribute @SessionAttributes @PathVariable @RequestParam @ResponseBody @Component @Repository
-----------------------------------------------------------------
控制，请映，资源，自载，模属，话属，径参，请参，复体，组件，仓库
空袭，青映，猪园，猪崽，毛叔（满身长满毛的大叔），华叔（刘德华大叔），（两人分别提起）荆铲（带荆刺的铲），青铲（青色的铲）（出发），福体（把“福”字贴在身体上），（跑向藏有）狙（和）箭（的），仓库（取武器）
-----------------------------------------------------------------

JVM : Eden Survivor To From Old
-----------------------------------------------------------------
亚当 丝袜 兔 火鳞 鸥
亚当（的）丝袜（被）兔（衔走了）（亚当请来）火鳞鸥（帮忙捉住兔子）
-----------------------------------------------------------------

jdbc流程
-----------------------------------------------------------------
forName DriverManager getConnection prepareStatement executeQuery next
为名 驱管 获连 预编 执行 next
座（位）名（片上），（四驱）车（被）管（子插在上面），（座位上摆着）锅（锅里放着）（榴）莲，鱼片，汁（的）痕（迹）（也在上面），纳什（到了后一脸懵逼）
-----------------------------------------------------------------

JavaScript 六种继承
-----------------------------------------------------------------
简单原型链 借用构造函数 组合继承（最常用） 原型式 寄生式 寄生组合继承（最佳方式）
简原 借构 组继 原型 寄生 寄组
（发现）（一块）碱（在）（草）原（上），借（了一条）狗（谐构），（拿了一把）狙击（上前去捡起来），（路上发现）（草）原（的）（苍）蝇，（在叮着一件）记（者的）衫（谐生），（旁边还有一碗）鸡粥
-----------------------------------------------------------------

execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
-----------------------------------------------------------------
执行 修饰 返回 属类 方法 参数 异常
（把）汁（谐执）（倒进）坑（谐行）（里），（冲出一块看上去）锈（谐修）（迹斑斑的）石（谐饰）（头），（取回去和）饭（谐返）（还有）芋（谐回）（一起煲），（然后问街上卖苞）粟（谐属）（的）女（谐类），（要了些四）方（形的）（苞粟）花（谐法），（以及）长（谐参）（长的）（苞粟）须（谐数）（放进去一起煲），姨（谐异）（用）勺（谐常）（子）（把食材搞匀）
-----------------------------------------------------------------

一对多，多的插入字段;一对一，选其中之一插入字段;多对多，建关联表
-----------------------------------------------------------------
一多，多插，一一，选插，多多，关联
一刀（刺中），多（个）猹，一休，（用）线（把）猹（穿起来），多多（黄磊女儿），（把穿起来的猹）挂（在）（窗）帘（前）
-----------------------------------------------------------------

数据三范式
第一范式：强调的是列的原子性，即列不能够再分成其他几列。
第二范式：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
第三范式：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
-----------------------------------------------------------------
一范，列原（列的原子性）;二范，全依主（完全依赖于主键）;三范，不传赖（不能存在传递依赖）
一凡（李一凡）（在旅途中），列（车在）（草）原（上飞驰），（车上的伙食是）鱼饭（和）（烤）全乳猪，（一凡特地）（舀了）三（碗）饭，（给）白拳（树）懒
-----------------------------------------------------------------

mybatis几个主要标签：mapper，namespace，select（增删查改其中之一），id，resultType，parameterType
-----------------------------------------------------------------
（映）射，名（域），选（择），（I）D，果（类），参（类）
树明（在街上）选D（苹）果橙（子回家吃）
-----------------------------------------------------------------

可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。
-----------------------------------------------------------------
可见，一修共，另不见
（荷）叶（猪）肩，（被）一休（用）弓（箭射走了），（廖小）玲（生气得）拔剑（了）
-----------------------------------------------------------------

ThreadLocal
-----------------------------------------------------------------
ThreadLocal在所在对象被多线程调用时起效
线本在象多调效
（五）线（谱）本（子）在（大）象（身上）（叫了）多（个）雕（把本子）咬（起来）
-----------------------------------------------------------------

四种线程池
newCachedThreadPool newFixedThreadPool newScheduledThreadPool newSingleThreadExecutor
-----------------------------------------------------------------
线池 缓存 固定 定时 单例
（向硫）酸池（倒下一）碗（铜）钱（结果爆炸）（屁）股（被一枚飞出来的）（铁）钉（扎中）（铁）钉（还刺中旁边的）（番）薯（为了安全起见）担泥（把池子填了）
-----------------------------------------------------------------

jsp九大内置对象
request response out session application config pageContext page Exception
-----------------------------------------------------------------
请求 回复 输出 会话 应用 配置 上下（文） 页面 异常
（一颗）青（色）（的）球（被一个）回（族人）（误吞进）腹（里）（痛苦得他用一本）书（乱）插（肚子）（这时唯有用）绘画（写生来转移注意力）（他发现有一个）蝇蛹（在一个玉）佩（的）珠（子上）（吸引了）蛇（和）蛤（蟆）（他看得入迷）（不小心打翻了）腌面（弄脏了）衣裳
-----------------------------------------------------------------

类的初始化顺序
总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法
-----------------------------------------------------------------
静 变 构
井（边）（用）鞭（子）（抽打）狗
-----------------------------------------------------------------

sql匹配符
-----------------------------------------------------------------
% _ [] [^] [-]

百分号 下划线 中括号 ^ 减号
百下中^减
（王）伯何（口）盅（里有一条）鸭颈
-----------------------------------------------------------------

spring事务控制
-----------------------------------------------------------------

-----------------------------------------------------------------

web实现“切换tab”功能的方法之一：
1、设置相等数量的<li>和<div>
2、设置触发函数
3、获取被点击的<li>的index
4、设置被点击的<li>的属性（如：class）为特定值，其他<li>回归到初始属性
5、将<li>对应的<div>show出来，其余的<div>hide起来
-----------------------------------------------------------------
等量 触发 索引 特定 初始 show|hide
（一间屋子里）灯亮（了）（一位女子在）束发（这时窗边突然有条）索（子）（垂着）（下来了一个）忍(者)（并向该女子飞了一颗）毒钉（女子凭着自己的特异功能）搓（手掌搓出了好几根）刺（女子用这些刺回击忍者）（刺中了忍者的）手（和）嗨
-----------------------------------------------------------------

脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）
幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
-----------------------------------------------------------------
脏读：读未提（读取了未提交的事务的操作结果）
不重：同条异（重复读取同一条数据有着相异的结果）
幻读：查多异（重复查询（或更改）多条数据有着相异的结果）
（案发现场）（尸体）（心）脏（被）刀（插着）刀尾（用）锑（皮）（包着）（尸体上已有）白（色）虫（子）（调查人员随手扔了一条给一旁的）（水）桶（里）（不停）跳（起来的）鱼（吃）（尸体手边的）环（首）刀插（着）多（条）（烤）鱼
-----------------------------------------------------------------

数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。
-----------------------------------------------------------------
Read uncommitted、Read committed、Repeatable read、Serializable
读未提、读提交、可重读、序列化
毒（品）（被）美（羊羊）提（着）（她提着）毒（品）（到）（河）堤（边）（喂给河里的）（马）鲛（鱼）河（里的）虫（子）（都）（中）毒（浮了起来）（马鲛鱼的）嘴（也）裂（了）（一）块（出来）
-----------------------------------------------------------------

http状态码
-----------------------------------------------------------------

-----------------------------------------------------------------

git冲突
冲突标记<<<<<<< （7个<）与=======之间的内容是我的修改，=======与>>>>>>>之间的内容是别人的修改。
小于号和等号之间的内容是我做的修改
等号与大于号之间的内容是别人的修改
-----------------------------------------------------------------
小等我，等大别
（坐在）小凳（子上的）我（正在用）灯（照着一个）大鳖
-----------------------------------------------------------------

git回滚
git reset --hard 版本号
-----------------------------------------------------------------
git 重 杆 硬 号
（北）极（圈里的）（一棵）松（树）（的）（树）干（上）（挂着）银（色的）（小）号
-----------------------------------------------------------------

Spring事务传播行为
-----------------------------------------------------------------
TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。
TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。
要求 求新 支持 不支 从不 强制 嵌套
（城宽）腰（间抱着一个）球（读着）（阿）舅（的）信（读完后，拿着）（信）纸（去）厕（所）（了）（另外用一些）白（信）纸（包起吃了一半的）葱包（厕所开关坏了，需要用）钳（子）（拧开）制（接着准备拉屎，拉屎前在）线（上）（搭起自己的）（外）套
-----------------------------------------------------------------

向上转型会失去继承类里的方法，向下转型先要被继承类对象赋值
-----------------------------------------------------------------
向上失继，向下先继
香肠塞（进）鸡（肚子里），（然后放进）箱子（里），（箱子里还有）虾（和）蒜鸡
-----------------------------------------------------------------

6222 6007 1001 8248 916 
-----------------------------------------------------------------
老爷爷（622）拿鱼肉（26）给007吃时，掏出一本《一千零一夜》（1001），再从书里拿出一条白鱼（82），然后书爆（48）了，吓得狗入笼（916）了
-----------------------------------------------------------------

Spring三种注入方式
接口注入（不推荐）
getter，setter方式注入（比较常用）
构造器注入（死的应用）
-----------------------------------------------------------------
三注、接、get/set、构
山猪，（路过，发现一把）遮（伞）（下）（有一个）（被）巨石（压住的）狗
-----------------------------------------------------------------

autowire="defualt"
autowire="byName"
autowire="bytype"
autowire="constructor"
-----------------------------------------------------------------
autowire default byName bytype constructor
鹅肚蛙，大火（烤），白泥（包裹），（烤好后放在）白台（上），狗走（过来）
-----------------------------------------------------------------

拦截器：1、反射 2、不依赖于servlet容器
过滤器：1、回调 2、依赖于servlet容器
-----------------------------------------------------------------
拦截，反射，不servlet
过滤，回调，依servlet
烂遮，（下有）番薯（堆），（有）白蛇
（扔一个）（苹）果（引爆）（地）雷，（炸得）（一个）回（族人）跳（起来），（他的）耳（朵）（被飞起的）石（头）（击伤）
-----------------------------------------------------------------

JAVA反射机制
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
-----------------------------------------------------------------
反射，类知，属法，象调，法属
（大）番薯，（看）女子，（写）书法，（在）（大）象（的）屌（上），（大番薯给女子的书法打了个）分数
-----------------------------------------------------------------

Java作用域（当前类、同一包内、子孙类、其他包）
public > protected > default > private
-----------------------------------------------------------------
公护默私，类包子all
（外）公（在）湖（边）抹屎，（这时）（地）雷爆（了），屎（炸飞）（落到）（湖中的）（天）鹅（身上）
-----------------------------------------------------------------

throws和throw的区别：
1、throws出现在方法函数头；而throw出现在函数体。
2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。
3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。
-----------------------------------------------------------------
throws throw 函头 函体 不定 必抛 不理 上层
（捡到一个）死老鼠，撕肉，含头，含体，拔钉，（和着）冰雹（一起吃），（吃出了）玻璃，（还是）双层（的）
-----------------------------------------------------------------

抽象类和接口的区别:

1，抽象类里可以有构造方法，而接口内不能有构造方法。

2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。

3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。

4，抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

5，抽象类中可以包含静态方法，接口内不能包含静态方法。

6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public  static类型，并且默认为public static类型。

7，一个类可以实现多个接口，但只能继承一个抽象类。

再补充点两者在应用上的区别：

接口更多的是在系统框架设计方法发挥作用，主要定义模块之间的通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用
-----------------------------------------------------------------

-----------------------------------------------------------------