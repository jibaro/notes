AOP原理：
-----------------------------------------------------------------
代理实例，loader，父类，handler，method，调用，代理对象，参数
【大理石林（里），榴弹，（装在）裤里，憨豆，梅（威）瑟，（穿着）貂绒，（用）大理对象，撑船（逃跑）】

enhancer，设父（设置父类），回调（设置回调），创造（创建代理对象），调父（invokeSuper）
【耀汉，切肤，（痛得）喂（地叫）跳（起来），（跳去）床灶，脱裤】
-----------------------------------------------------------------

这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
-----------------------------------------------------------------
运行 动态 类 方法 位置
-----------------------------------------------------------------

八种排序方法
-----------------------------------------------------------------
直接插入排序，希尔排序，冒泡排序，快速排序，直接选择排序，堆排序，归并排序，基数排序
分别取第一个字
直希冒快直堆归基
蒸气（上的飘着的）毛（着）火，（蒸气源头的）（树）枝堆（下有）鬼机（闹鬼飞机）
-----------------------------------------------------------------

泛型
-----------------------------------------------------------------
泛型标志<T>在类名的后面或方法返回类型的前面
类后返前
你好犯贱
-----------------------------------------------------------------

RMI
-----------------------------------------------------------------

-----------------------------------------------------------------

线程
-----------------------------------------------------------------
Thread套Runnable（必须用new Thread()套住实现Runnable接口的类，此类才能start()）
仙桃（被）龙拿（了）
-----------------------------------------------------------------

麻将
-----------------------------------------------------------------
打麻将时，碰就扔一个子，干就摸一个子
碰人干摸
碰（撞别）人（的）肛（门里的）膜
-----------------------------------------------------------------

Redis的键值可以使用5种数据类型：字符串(Strings)，散列表(hashes)，列表(Lists)，集合(Sets 求交集、并集)，有序集合(Sorted Sets)
-----------------------------------------------------------------
Redis 字 散 列 集 序
绿地（谐Redis）（上有一把）（带）字（的）伞（谐散），裂（谐列）（了），（看上去是被旁边一个）执（谐集）锥（谐序）（的人弄裂的）
-----------------------------------------------------------------

volatile在多线程环境下，可以做到：1、防止重排序，2、实现可见性，3、但不能保证原子性
-----------------------------------------------------------------
volatile防重，可见，不原
锅（谐volatile）（里）放葱，荷肩（荷叶包着的猪肩），（还有）白盐（谐不原）
-----------------------------------------------------------------

Java变量命名规范
-----------------------------------------------------------------
首字母是英文字母、$和下划线，由英文字母、数字和下划线组成。（备注：可以为英文字母，也可以是汉字）
首字$下，字数下组
手指撕（$）虾，（用手）指数虾（和红）枣
-----------------------------------------------------------------

英菲尼迪：日产，讴歌：本田
-----------------------------------------------------------------
英日歌本
鹰（飞在）日（下）（位置：）哥（谐歌）本（哈根）
-----------------------------------------------------------------

-zxvf
-----------------------------------------------------------------
纸箱（是从）潍坊（寄过来的）
-----------------------------------------------------------------

case when then else end
-----------------------------------------------------------------
骑士（谐case）玩（谐when）蛋（谐then）L（谐else）籺（谐end）
-----------------------------------------------------------------

springMVC常用标签
@Controller @RequestMapping @Resource @Autowired @ModelAttribute @SessionAttributes @PathVariable @RequestParam @ResponseBody @Component @Repository
-----------------------------------------------------------------
控制，请映，资源，自载，模属，话属，径参，请参，复体，组件，仓库
空袭，青映，猪园，猪崽，毛叔（满身长满毛的大叔），华叔（刘德华大叔），（两人分别提起）荆铲（带荆刺的铲），青铲（青色的铲）（出发），福体（把“福”字贴在身体上），（跑向藏有）狙（和）箭（的），仓库（取武器）
-----------------------------------------------------------------

JVM : Eden Survivor To From Old
-----------------------------------------------------------------
亚当 丝袜 兔 火鳞 鸥
亚当（的）丝袜（被）兔（衔走了）（亚当请来）火鳞鸥（帮忙捉住兔子）
-----------------------------------------------------------------

jdbc流程
-----------------------------------------------------------------
forName DriverManager getConnection prepareStatement executeQuery next
为名 驱管 获连 预编 执行 next
座（位）名（片上），（四驱）车（被）管（子插在上面），（座位上摆着）锅（锅里放着）（榴）莲，鱼片，汁（的）痕（迹）（也在上面），纳什（到了后一脸懵逼）
-----------------------------------------------------------------

JavaScript 六种继承
-----------------------------------------------------------------
简单原型链 借用构造函数 组合继承（最常用） 原型式 寄生式 寄生组合继承（最佳方式）
简原 借构 组继 原型 寄生 寄组
（发现）（一块）碱（在）（草）原（上），借（了一条）狗（谐构），（拿了一把）狙击（上前去捡起来），（路上发现）（草）原（的）（苍）蝇，（在叮着一件）记（者的）衫（谐生），（旁边还有一碗）鸡粥
-----------------------------------------------------------------

execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
-----------------------------------------------------------------
执行 修饰 返回 属类 方法 参数 异常
（把）汁（谐执）（倒进）坑（谐行）（里），（冲出一块看上去）锈（谐修）（迹斑斑的）石（谐饰）（头），（取回去和）饭（谐返）（还有）芋（谐回）（一起煲），（然后问街上卖苞）粟（谐属）（的）女（谐类），（要了些四）方（形的）（苞粟）花（谐法），（以及）长（谐参）（长的）（苞粟）须（谐数）（放进去一起煲），姨（谐异）（用）勺（谐常）（子）（把食材搞匀）
-----------------------------------------------------------------

一对多，多的插入字段;一对一，选其中之一插入字段;多对多，建关联表
-----------------------------------------------------------------
一多，多插，一一，选插，多多，关联
一刀（刺中），多（个）猹，一休，（用）线（把）猹（穿起来），多多（黄磊女儿），（把穿起来的猹）挂（在）（窗）帘（前）
-----------------------------------------------------------------

数据三范式
第一范式：强调的是列的原子性，即列不能够再分成其他几列。
第二范式：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
第三范式：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
-----------------------------------------------------------------
一范，列原（列的原子性）;二范，全依主（完全依赖于主键）;三范，不传赖（不能存在传递依赖）
一凡（李一凡）（在旅途中），列（车在）（草）原（上飞驰），（车上的伙食是）鱼饭（和）（烤）全乳猪，（一凡特地）（舀了）三（碗）饭，（给）白拳（树）懒
-----------------------------------------------------------------

mybatis几个主要标签：mapper，namespace，select（增删查改其中之一），id，resultType，parameterType
-----------------------------------------------------------------
（映）射，名（域），选（择），（I）D，果（类），参（类）
树明（在街上）选D（苹）果橙（子回家吃）
-----------------------------------------------------------------

可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。
-----------------------------------------------------------------
可见，一修共，另不见
（荷）叶（猪）肩，（被）一休（用）弓（箭射走了），（廖小）玲（生气得）拔剑（了）
-----------------------------------------------------------------

ThreadLocal
-----------------------------------------------------------------
ThreadLocal在所在对象被多线程调用时起效
线本在象多调效
（五）线（谱）本（子）在（大）象（身上）（叫了）多（个）雕（把本子）咬（起来）
-----------------------------------------------------------------

四种线程池
newCachedThreadPool newFixedThreadPool newScheduledThreadPool newSingleThreadExecutor
-----------------------------------------------------------------
线池 缓存 固定 定时 单例
（向硫）酸池（倒下一）碗（铜）钱（结果爆炸）（屁）股（被一枚飞出来的）（铁）钉（扎中）（铁）钉（还刺中旁边的）（番）薯（为了安全起见）担泥（把池子填了）
-----------------------------------------------------------------

jsp九大内置对象
request response out session application config pageContext page Exception
-----------------------------------------------------------------
请求 回复 输出 会话 应用 配置 上下（文） 页面 异常
（一颗）青（色）（的）球（被一个）回（族人）（误吞进）腹（里）（痛苦得他用一本）书（乱）插（肚子）（这时唯有用）绘画（写生来转移注意力）（他发现有一个）蝇蛹（在一个玉）佩（的）珠（子上）（吸引了）蛇（和）蛤（蟆）（他看得入迷）（不小心打翻了）腌面（弄脏了）衣裳
-----------------------------------------------------------------

类的初始化顺序
总的来说，初始化顺序依次是：（静态变量、静态初始化块）–>（变量、初始化块）–> 构造器；如果有父类，则顺序是：父类static方法 –> 子类static方法 –> 父类构造方法- -> 子类构造方法
-----------------------------------------------------------------
静 变 构
井（边）（用）鞭（子）（抽打）狗
-----------------------------------------------------------------

sql匹配符
-----------------------------------------------------------------
% _ [] [^] [-]

百分号 下划线 中括号 ^ 减号
百下中^减
（王）伯何（口）盅（里有一条）鸭颈
-----------------------------------------------------------------

spring事务控制
-----------------------------------------------------------------

-----------------------------------------------------------------

web实现“切换tab”功能的方法之一：
1、设置相等数量的<li>和<div>
2、设置触发函数
3、获取被点击的<li>的index
4、设置被点击的<li>的属性（如：class）为特定值，其他<li>回归到初始属性
5、将<li>对应的<div>show出来，其余的<div>hide起来
-----------------------------------------------------------------
等量 触发 索引 特定 初始 show|hide
（一间屋子里）灯亮（了）（一位女子在）束发（这时窗边突然有条）索（子）（垂着）（下来了一个）忍(者)（并向该女子飞了一颗）毒钉（女子凭着自己的特异功能）搓（手掌搓出了好几根）刺（女子用这些刺回击忍者）（刺中了忍者的）手（和）嗨
-----------------------------------------------------------------

脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）
幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
-----------------------------------------------------------------
脏读：读未提（读取了未提交的事务的操作结果）
不重：同条异（重复读取同一条数据有着相异的结果）
幻读：查多异（重复查询（或更改）多条数据有着相异的结果）
（案发现场）（尸体）（心）脏（被）刀（插着）刀尾（用）锑（皮）（包着）（尸体上已有）白（色）虫（子）（调查人员随手扔了一条给一旁的）（水）桶（里）（不停）跳（起来的）鱼（吃）（尸体手边的）环（首）刀插（着）多（条）（烤）鱼
-----------------------------------------------------------------

数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。
-----------------------------------------------------------------
Read uncommitted、Read committed、Repeatable read、Serializable
读未提、读提交、可重读、序列化
毒（品）（被）美（羊羊）提（着）（她提着）毒（品）（到）（河）堤（边）（喂给河里的）（马）鲛（鱼）河（里的）虫（子）（都）（中）毒（浮了起来）（马鲛鱼的）嘴（也）裂（了）（一）块（出来）
-----------------------------------------------------------------

http状态码
-----------------------------------------------------------------

-----------------------------------------------------------------

git冲突
冲突标记<<<<<<< （7个<）与=======之间的内容是我的修改，=======与>>>>>>>之间的内容是别人的修改。
小于号和等号之间的内容是我做的修改
等号与大于号之间的内容是别人的修改
-----------------------------------------------------------------
小等我，等大别
（坐在）小凳（子上的）我（正在用）灯（照着一个）大鳖
-----------------------------------------------------------------

git回滚
git reset --hard 版本号
-----------------------------------------------------------------
git 重 杆 硬 号
（北）极（圈里的）（一棵）松（树）（的）（树）干（上）（挂着）银（色的）（小）号
-----------------------------------------------------------------

Spring事务传播行为
-----------------------------------------------------------------
TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。
TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。
要求 求新 支持 不支 从不 强制 嵌套
（城宽）腰（间抱着一个）球（读着）（阿）舅（的）信（读完后，拿着）（信）纸（去）厕（所）（了）（另外用一些）白（信）纸（包起吃了一半的）葱包（厕所开关坏了，需要用）钳（子）（拧开）制（接着准备拉屎，拉屎前在）线（上）（搭起自己的）（外）套
-----------------------------------------------------------------

向上转型会失去继承类里的方法，向下转型先要被继承类对象赋值
-----------------------------------------------------------------
向上失继，向下先继
香肠塞（进）鸡（肚子里），（然后放进）箱子（里），（箱子里还有）虾（和）蒜鸡
-----------------------------------------------------------------

6222 6007 1001 8248 916 
-----------------------------------------------------------------
老爷爷（622）拿鱼肉（26）给007吃时，掏出一本《一千零一夜》（1001），再从书里拿出一条白鱼（82），然后书爆（48）了，吓得狗入笼（916）了
-----------------------------------------------------------------

Spring三种注入方式
接口注入（不推荐）
getter，setter方式注入（比较常用）
构造器注入（死的应用）
-----------------------------------------------------------------
三注、接、get/set、构
山猪，（路过，发现一把）遮（伞）（下）（有一个）（被）巨石（压住的）狗
-----------------------------------------------------------------

autowire="defualt"
autowire="byName"
autowire="bytype"
autowire="constructor"
-----------------------------------------------------------------
autowire default byName bytype constructor
鹅肚蛙，大火（烤），白泥（包裹），（烤好后放在）白台（上），狗走（过来）
-----------------------------------------------------------------

拦截器：1、反射 2、不依赖于servlet容器
过滤器：1、回调 2、依赖于servlet容器
-----------------------------------------------------------------
拦截，反射，不servlet
过滤，回调，依servlet
烂遮，（下有）番薯（堆），（有）白蛇
（扔一个）（苹）果（引爆）（地）雷，（炸得）（一个）回（族人）跳（起来），（他的）耳（朵）（被飞起的）石（头）（击伤）
-----------------------------------------------------------------

JAVA反射机制
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
-----------------------------------------------------------------
反射，类知，属法，象调，法属
（大）番薯，（看）女子，（写）书法，（在）（大）象（的）屌（上），（大番薯给女子的书法打了个）分数
-----------------------------------------------------------------

Java作用域（当前类、同一包内、子孙类、其他包）
public > protected > default > private
-----------------------------------------------------------------
公护默私，类包子all
（外）公（在）湖（边）抹屎，（这时）（地）雷爆（了），屎（炸飞）（落到）（湖中的）（天）鹅（身上）
-----------------------------------------------------------------

throws和throw的区别：
1、throws出现在方法函数头；而throw出现在函数体。
2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。
3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。
-----------------------------------------------------------------
throws throw 函头 函体 不定 必抛 不理 上层
（捡到一个）死老鼠，撕肉，含头，含体，拔钉，（和着）冰雹（一起吃），（吃出了）玻璃，（还是）双层（的）
-----------------------------------------------------------------

抽象类和接口的区别:

1，抽象类里可以有构造方法，而接口内不能有构造方法。

2，抽象类中可以有普通成员变量，而接口中不能有普通成员变量。

3，抽象类中可以包含非抽象的普通方法，而接口中所有的方法必须是抽象的，不能有非抽象的普通方法。

4，抽象类中的抽象方法的访问类型可以是public ，protected和默认类型，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

5，抽象类中可以包含静态方法，接口内不能包含静态方法。

6，抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public  static类型，并且默认为public static类型。

7，一个类可以实现多个接口，但只能继承一个抽象类。

再补充点两者在应用上的区别：

接口更多的是在系统框架设计方法发挥作用，主要定义模块之间的通信，而抽象类在代码实现方面发挥作用，可以实现代码的重用
-----------------------------------------------------------------
抽象 接口 构造 普变 非象法 象法类 静法 任静变
（把）秋（刀鱼）（喂给）大象（吃），（用手电筒）照（大象的）口（看吃完没有），（发现吃完了）（又拿来）狗（肉）粥（给大象吃），（趁大象在吃）抱（大象的）（粪）便（出去），（发现墙上有朵花）飞（上）墙（去采摘）花，（在墙上看到一个）长发女，（忍不住）（射）精（在她的）（头）发（上），（居然这个是任静），任静（一）鞭（甩过来）
-----------------------------------------------------------------

Shiro Features
Authentication     Authorization
Session Management Cryptography
Web Support        Caching
Concurrency Testing "Run as" Remember me
-----------------------------------------------------------------
Shiro 特征 认证 授权 话管 加密 网支 缓存 并发 测试 作运 记我
（番）薯（放在）箩（筐上），（摆卖，却不见卖家）（旁边有口）大井，（有个）人（从）井（里爬出来）（这人就是卖家），（他）手（上）（戴着）圈（子），（从井里捞起一个）话（梅）罐，（里面除了话梅还有）瓜米，（罐上印着）网址，碗（里放着）串（起来的）（话梅），（准备和着饼吃）饼（却被）花（粉）（弄脏了），（生气地把一串话梅）插（进）屎（里），（最后找出）（用）作文（纸）（包着的）鸡鹅（来吃）
-----------------------------------------------------------------

Shiro Detailed Architecture
Security Manager(Authenticator(Authentication Strategy)、Authorizer、Session Manager、Pluggable Realms、Session Dao、Cache Manager)、Cryptography
-----------------------------------------------------------------
Shiro 架构 安管 认证（证策） 授权 话管 插域 话dao cache管 加密
食肉（后），（给）瓜狗（吃），（发现）桉（树上挂着）（某人的）证（件），（看了看）（把）证（件）（扔进）（垃圾）笧，（突然一个猛）兽（挥）拳（打过来），（躲过后）挖（出）（一条）（水）管，（猛插过去，没插中）插（进了）（远处的）（游）泳（池里），（再）挖（出一把）刀，砍（爆）（地里的）（雷）管，（炸出一堆）瓜米
-----------------------------------------------------------------

Java正则表达式
Matcher m = Pattern.compile("(\\S+)\\s*(\\S*)").matcher(text);
while (m.find()) {
	System.out.println(m.group(1) + ":" + m.group(2));
}

matcher.matches();
-----------------------------------------------------------------
m= 样式 编译 正则 匹配 文本 while m.find() 组1 组2 matcher.matches();
（一个）盎（放在）凳子（上），羊（拉）屎（在盎里），（仆人在盎边发现了）蝙（蝠）翼（捡起蝙蝠翼），（拿去）蒸（笼）（里）（蒸出）汁，（然后盛了一碗汁去伺候病人），（到了病人身边后），拍（拍）（病人的）背，（拿）（作）文本（给他看），（帮他）挖耳，（又拿）M（P）5（给他玩），（还有狙击），（病人用狙击）狙鸭（子），狙鱼（儿），（仆人在病人玩的时候），（出去）抹车，抹泳（池）（了）
-----------------------------------------------------------------

cron 秒 分 时 日 月 周 年
-----------------------------------------------------------------
cron 周 年
黑狼走（在）（电）线（上）
-----------------------------------------------------------------

Map多种遍历
//第一种：普遍使用，二次取值
System.out.println("通过Map.keySet遍历key和value：");
for (String key : map.keySet()) {
	System.out.println("key= "+ key + " and value= " + map.get(key));
}

//第二种
System.out.println("通过Map.entrySet使用iterator遍历key和value：");
Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();
while (it.hasNext()) {
	Map.Entry<String, String> entry = it.next();
	System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
}

//第三种：推荐，尤其是容量大时
System.out.println("通过Map.entrySet遍历key和value");
for (Map.Entry<String, String> entry : map.entrySet()) {
	System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
}

//第四种
System.out.println("通过Map.values()遍历所有的value，但不能遍历key");
for (String v : map.values()) {
	System.out.println("value= " + v);
}
-----------------------------------------------------------------
第二和第三种差不多，记住了第二种就可以认为第三种也记住了
麦（田旁边有）避雷（针），（避雷针旁有个火箭发射场，里面的）火箭（正在发射升空，升空时形成的强大气流把）鸡毛（从）鸡锡（上吹飞），鸭（子）（吓得跃上）马鞍（顺便在马鞍上吃了）串串（串起来的）籺，马（转过头来咬）鸭锡（和）翼，（鸭为了求救），（点）火（烧着）钱（呼唤）麦（田里的）猪（过来帮忙）
-----------------------------------------------------------------

jdk动态代理
public class User {
	private int id;
	public int getId() {return id;}
	public void setId(int id) {this.id = id;}
}

public interface UserService {
	public void addUser(User user);
	public User getUser(int id);
}

public class UserServiceImpl implements UserService {
	public void addUser(User user) {System.out.println("add user into database.");}
	public User getUser(int id) {
		User user = new User();
		user.setId(id);
		System.out.println("getUser from database.");
		return user;
	}
}

public class ProxyUtil implements InvocationHandler {
	private Object target; // 被代理的对象
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		System.out.println("do sth before....");
		Object result = method.invoke(target, args);
		System.out.println("do sth after....");
		return result;
	}
	ProxyUtil(Object target) {this.target = target;}
	public Object getTarget() {return target;}
	public void setTarget(Object target) {this.target = target;}
}

public class ProxyTest {
	public static void main(String[] args) {
		Object proxyedObject = new UserServiceImpl(); // 被代理的对象
		ProxyUtil proxyUtils = new ProxyUtil(proxyedObject);
		// 生成代理对象，对被代理对象的这些接口进行代理：UserServiceImpl.class.getInterfaces()
		UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
				UserServiceImpl.class.getInterfaces(), proxyUtils);
		proxyObject.getUser(1);
		proxyObject.addUser(new User());
	}
}
-----------------------------------------------------------------
j动（jdk动态代理）、ProxyUtil、实现、（调处）InvocationHandler、（Object target）、（Object invoke）、（Object proxy）、（Method method）、（Object[] args）、（throws Throwable）、before、（Object result）、（method.invoke）、（target, args）、after、（return result;）、构造 target、ProxyTest main、（Object proxyedObject）、（new UserServiceImpl()）、ProxyUtil proxyUtils、new ProxyUtil(proxyedObject)、UserService、proxyObject、Proxy newProxyInstance、Thread.currentThread().getContextClassLoader()、UserServiceImpl.class.getInterfaces()、proxyUtils、向下、proxyObject.getUser(1);、proxyObject.addUser(new User());
（一只）（野）鸡（钻进）洞（里），袋（鼠）跳（过来），（往洞里）撒盐，雕（也过来，站在）柱（子上）观望，象（也想吃鸡，过来）踏（塌了洞口），象（躯干走）雕，象（驱赶走）袋（鼠），（又过来一只）狒狒，象（用）（红）枣（泡）茶（喂狒狒，从而赶走了狒狒），（但有个一小）人（骑着一个大）人（过来），（捅破了）（墙）壁（上的）蜂（窝），（大）象（的）哥（哥）（带着大象跑了），（躲在）花（丛中的）雕，踢（起一把）铲（飞向一个）盎蜂（窝），（顿时漫天都是蜂），（雕）翻盖（想躲避），（盖里的）狗（一脚）踢（开雕），（雕唯有整个）插（进）米（里躲避），象（返回）（扛了一）袋酱（过来），（还有）（用）信（封）（装着的）火机，（解开系在袋口的）牛（皮）（皮）带，（大象）头（上）（插着）（花）朵（戴着）（蚊）帐（作防护），（把）（一只）蛹（用打火机点着）火（搭乘）大疆（无人机上，空投到袋里），（整）袋（爆开）（裂成）三（块）大石，（三块大石再裂开）（出来一些）（用）酸（泡过）（且）绑（着）线（的）榴弹，（还有）辐射雷，（一个）曱甴（的触动引起了爆炸），（炸）弹跳（起），（爆开），（撒出遮天盖日的）糠（飘）下，大象（回）家（扛）石油（向火场浇）
-----------------------------------------------------------------
树形记忆测试
-----------------------------------------------------------------
j动 ProxyUtil （ProxyTest Main）
机动（战士）（在）（北京）大桥（上）（拦了一辆）车（车上装着）（大）米
	ProxyUtil （Object target） （Object invoke） 构造 getTarget setTarget
	袋（鼠）跳（起来）（溅起的）（泥）浆（弄脏了）（大象的）头，（站在大象背上的）雕，呕粥（出来还击袋鼠），（还扔）（含）镉（的）石头
		（Object invoke） （Object proxy） before （Object result） after （return result）
		象（背上的）雕（飞下去）（啄爆一个）涨（起来的）袋，（炸出一堆）壁虎（和）浆果（引来一群）盎蜂，（雕唯有）翻（开）盖（躲进去避避）
			（Object proxy） （Method method） （Object[] args） （throws Throwable）
			涨袋（打开一看）（里面有一只）狒狒（在啃着）长须参，（见到人还）扔（东西砸）人
			（Object result） method.invoke (target, args)
			浆果（泡在）花雕（酒里），（酒埋在）泰山（脚下）
	（ProxyTest Main） （Object proxyedObject） ProxyUtil UserService getUser addUser
	（货）车（上）（装着一包包）（大）米，（车上还有一缸黄豆）浆（里）（泡着）（豆腐）皮（和）大象，（旁边的一个）袋（子）跳（起来）
	，溶（化）（并）（着）火，（燃烧过程中）（流出）鸡鸭油
		Object proxyedObject = new UserServiceImpl();
		（用）橡皮（使劲擦拭）大（幅）奖（状）（奖状着火了），（引燃了整个）（农村）信用（社），火鼠（被火烧着的老鼠）（跑出来）
		ProxyUtil proxyUtils = new ProxyUtil(proxyedObject);
		袋（鼠）跳（起来），（导致）（装）信（件的）袋（子）断（裂），（唯有用一条）背带（补起来）
		UserService proxyObject = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
				UserServiceImpl.class.getInterfaces(), proxyUtils);
		（把）（一只）蛹（用打火机点着）火（搭乘）大疆（无人机上，空投到袋里），（整）袋（爆开）（裂成）三（块）大石，（三块大石再裂开）（出来一些）
		（用）酸（泡过）（且）绑（着）线（的）（木柄）（手）榴弹，（还有）辐射雷，（一个）曱甴（的触动引起了爆炸），（炸）弹跳（起），（爆开）
		，（撒出遮天盖日的）糠（飘）下
-----------------------------------------------------------------

cglib代理
public class User 同上
public interface UserService 同上
public class UserServiceImpl implements UserService 同上

public class CGProxy implements MethodInterceptor {
	private Object target; // 被代理对象
	public CGProxy(Object target) {
		this.target = target;
	}
	public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy proxy) throws Throwable {
		System.out.println("do sth before....");
		Object result = proxy.invokeSuper(arg0, arg2);
		System.out.println("do sth after....");
		return result;
	}
	public Object getProxyObject() {
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(this.target.getClass()); // 设置父类
		// 设置回调
		enhancer.setCallback(this); // 在调用父类方法时，回调 this.intercept()
		// 创建代理对象
		return enhancer.create();
	}
}

public class CGProxyTest {
	public static void main(String[] args) {
		Object proxyedObject = new UserServiceImpl(); // 被代理的对象
		CGProxy cgProxy = new CGProxy(proxyedObject);
		UserService proxyObject = (UserService) cgProxy.getProxyObject();
		proxyObject.getUser(1);
		proxyObject.addUser(new User());
	}
}
-----------------------------------------------------------------
CGProxy、implements MethodInterceptor、Object target、public CGProxy(Object target)、Object intercept、Object arg0、Method arg1、Object[] arg2、MethodProxy proxy、throws Throwable、before、Object result、proxy.invokeSuper、(arg0, arg2)、after、return result;、Object getProxyObject、Enhancer enhancer = new Enhancer();、enhancer.setSuperclass、this.target.getClass()、enhancer.setCallback(this)、return enhancer.create();、CGProxyTest main、Object proxyedObject = new UserServiceImpl();、CGProxy cgProxy、new CGProxy(proxyedObject);、UserService proxyObject、(UserService) cgProxy.getProxyObject();、proxyObject.getUser(1);、proxyObject.addUser(new User());
（一只）死猪（在）袋（里），屎（和）（头）发（是）蓝（色的），（戴上）橡（胶）（手）套（准备处理），狗（过来）踢（了一下），（猪体）胀（裂）（射出）箭，（猪肠子露出来了）酱（在）肠（里）（肠子里还有）鲮（鱼），（以及）（都城）快餐（的）鱿（鱼），（此时）象（背着）枣（和）鲨鱼（回来了），（还有一只）狒（头上戴着花）朵（被装在）袋（子里），（一个）银（色的）人（骑着大象），（见此情此景，银人）拔斧，（喂了一块）姜（给）狗（吃），（还有）大屌蕉，（狗从）窗棂（旁拿过）长衣（穿起来），（提起）盎火，翻盖（做盾牌），（此时）象脚（边的一只）袋（鼠尸体又跟着）（膨）胀（起来），（见情况不能控制）（写）信（给）耀汉（过来），（另一边的耀汉正在用）电焊（制作一个）千秋（给）女（儿玩），（晚上做的晚饭是）猪肚（装）咖喱，（吃晚饭后，和女儿躺在草地上）（看着天上的）银河说哥白尼，（回到屋后）翻英汉（字）（在）床灶（上），（耀汉注意到）（垃圾）笧（里）（有）米，（还有）奖（状）（装在）（塑料）袋（子里）（塑料袋子里还有）浆（糊），（突然）（一张）信用（卡）（被）（身上着）火（的）（老）鼠（衔着走过），（送）信（的）树袋（熊）（刚好出现），（一个）大掌（拍死了老鼠），蛹（从）（老鼠）腹（部）（跑了出来）（还有）豆浆，（耀汉赶紧从）（放着）书（的）台脚（下的）斗（车里）（取出一把）遮，（用遮对着）箱（子）敲（检查还有没有其他生物在屋子里），（一敲），（出来一只）大（蠄）蠽，（它的钳子还）夹（着）鸭肉
-----------------------------------------------------------------
树形记忆测试
-----------------------------------------------------------------

-----------------------------------------------------------------

Oracle
没有使用聚合函数的列,必须出现在group by后面
出现在group by后面的列，不一定要被select和使用聚合函数
-----------------------------------------------------------------
没聚定在组后，组后不定选聚
抹狙（击枪）（然后把狙击枪）钉在（出）租（车）后（尾箱上），（来到草原）（用）狙（打死了一头）牛（这是一把射钉狙击）（从牛身上）拔（出）钉（后）（发现）（有）蒜（在牛）嘴（里）
-----------------------------------------------------------------

设值注意问题
空、null、带空格、格式、下标超出范围（数组、List等）、null调用方法
-----------------------------------------------------------------
（涂着）红（色）（颜料的）人（有着）大胸（穿着）格（子）衫（吃着）虾（米）（生）抽（拌）饭，拧（起）（头）发（以免被饭菜弄脏了）
-----------------------------------------------------------------

substring(a, b)
收下前面的索引a，抛弃后面的索引b
收前抛后
-----------------------------------------------------------------
（小姐）收（了）钱（就塞支）炮（进小姐）喉（咙）
-----------------------------------------------------------------

Windows CMD 鼠标窗口调出命令
control main.cpl
-----------------------------------------------------------------
鼠标 control main.cpl
（从）书包（里）（取出一把）（电子）琴（黑白键的那种），（然后在琴面上）搓（洗）米，（洗完后）（用）（螺）丝批（把琴键缝隙里的米撬出来）（用）瓯（乘着）
-----------------------------------------------------------------

PIVOT UNPIVOT
-----------------------------------------------------------------
PIVOT 聚合 for 竖 in 值
UNPIVOT 横值竖名 for 横名竖名 in 横
屁（股上的）毛（被用）嘴含（着），风（一吹）屎（忍不住拉出来了），（完事后）（用）烟（盒里的）纸（擦屁股）
MP（5）（射中）（一口）锅，（子弹反弹差点打中坐在）黄（色）遮（下的）树明，（树明用）火（点着一粒）话梅（然后射向）（挂在）树（上的）（玻璃）瓶（顿时）烟（雾）（呈）环（状）（包围着自己）
-----------------------------------------------------------------

Java 文件 IO
-----------------------------------------------------------------

-----------------------------------------------------------------

Java 日期 SimpleDateFormat系列
-----------------------------------------------------------------

-----------------------------------------------------------------

scope五个参数
singleton prototype request session (global session)
单例      模板      请求    会话    全局会话
-----------------------------------------------------------------
（一具）尸（体）（在被）狗（啃），（一个）担泥（的人路过看到了），（抡起一块）模板（把狗赶走），（他看到）青（色的）球，（意识到这是一处古墓），（于是用一只）碗挖（泥），（挖出了）钱（币）（和）谷（子），（还有）绘画
-----------------------------------------------------------------

@Autowired 根据类型注入
@Resource 默认根据名字注入，其次按照类型搜索
@Autowired @Qualifier("userService") 两个结合起来可以根据名字和类型注入？
-----------------------------------------------------------------
自载 类型 资源 名类 自载 合格
住宅（里）（一颗）（手）雷（爆炸），（苍）蝇（都飞了出来）（一只）紫（色的）猿（抱着）明（豪）（和明豪的）女（儿）（冲了出来），（明豪女儿怀里抱着）猪仔，（猪仔吃着）虾饺
-----------------------------------------------------------------

(new B()) instanceof A;
(new B()) instanceof B;
A a = new B();
a instanceof A
a instanceof B
instanceof（实例属） 子子 子父 true 向上 父子 父父 true
-----------------------------------------------------------------
猞猁（追逐一只）鼠，（震落了一只）蜘蛛（掉在）（张）志富（身上），（张志富）草（赶走了蜘蛛），（然而这时一条）响（尾）蛇（钻进了）裤子，（他立马从）葫（芦）壶（倒些）醋（进去驱走蛇）
-----------------------------------------------------------------

class param<T1, T2> {
	class A {}
	class B extends A {}
	private Class<T1> entityClass;
	public param() {
		Type type = getClass().getGenericSuperclass();
		System.out.println("getClass() == " + getClass());
		System.out.println("type = " + type);
		Type trueType = ((ParameterizedType) type).getActualTypeArguments()[0];
		System.out.println("trueType1 = " + trueType);
		trueType = ((ParameterizedType) type).getActualTypeArguments()[1];
		System.out.println("trueType2 = " + trueType);
		this.entityClass = (Class<T1>) trueType;
		System.out.println("entityClass = " + entityClass);

		B t = new B();
		type = t.getClass().getGenericSuperclass();
		System.out.println("B is A's super class :" + ((ParameterizedType) type).getActualTypeArguments().length);
	}
}
public class ClassDemo extends param<MyClass, MyInvoke> {
	public static void main(String[] args) {ClassDemo classDemo = new ClassDemo();}
}
输出结果：
getClass() == class reflectTest.reflectTest01.ClassDemo
type = reflectTest.reflectTest01.param<reflectTest.reflectTest01.MyClass, reflectTest.reflectTest01.MyInvoke>
trueType1 = class reflectTest.reflectTest01.MyClass
trueType2 = class reflectTest.reflectTest01.MyInvoke
entityClass = class reflectTest.reflectTest01.MyInvoke
B is A's super class :0
-----------------------------------------------------------------

-----------------------------------------------------------------

shiro demo
-----------------------------------------------------------------
（shiro demo） java sql resources webapp（网络应用，网应） target pom.xml
（外婆家）四楼（地上许多）屌毛，（屌毛堆中有只）蚱蜢（在啃）屎球，（屎球冒出一缕）紫烟，（一只）黄莺（飞过来向吃蚱蜢），头（却）（撞到）窗（上）（了）
	java common core permission user
	蚱蜢扛门（对抗）戈（的攻击），（相持之际，蚱蜢）拍（了一下）（拴住）猫（的）绳，（猫一动）（一袋）鱿（鱼）（和）蛇（砸在攻击者身上）
		common controller dao mapper model timer utils
		（王）嘉文（的）Ctrl（键）（被他用）刀（撬开）（然后用）抹布（去擦拭键盘）（抹着抹着，开始）抹屌，（嘉文high得）踢（了一脚）门，（吓得旁边的）牛跳（了起来）
			controller BaseController CommonController
			蠄（蜍）操（一颗）鼻屎，（结果鼻屎糊住了它的）肛门
			dao U Mapper Permission Role RolePermission User UserRole
			
			mapper U Mapper Permission Role RolePermission User UserRole
			
			model U Permission Role RolePermission User UserRole
			
		core config freemarker mybatis shiro statics tags
		哥（斯拉）扛（着肥料跑了），（追出来的有）火（麒）麟，（它隐私部位打着）马（赛）克，（还有）猫，（猫身上背着）铁支。（他们向哥斯拉）（发）射（了）（一只）锣（并击中），（哥斯拉被气得）撕大衣，踢（飞）（一坨）狗屎（作为还击）
			shiro cache filter listener service session token CustomShiroSessionDAO（CSSD）
			食肉（中的）盖茨（坐在）（一辆）飞度（FIT）（里面），（开车的是）李晨，（李晨被一块突如其来的）蛇皮（吓到），（车子撞上）石山，（附近）踢球（的一群小孩赶过来），（从车子里）扛（出）尸（体）（到）沙（子）（堆成的）岛（上）
				cache impl JedisManager JedisShiroCache JedisShiroSessionRepository ShiroCacheManager VCache
				盖茨（用）归参（喂）蚱蜢；谢诗琪（则用）（嵌有）结石（的）雪梨（和）沙琪玛喂狗
					impl CustomShiroCacheManager JedisShiroCacheManager
					（用）（一块）归参（引诱）蠄蜍（下来），（它正）（扛着）旗（站在）门（上），（不料被它用屎袭击），（不过用）遮（挡住了）屎，（打开）（飞）机门，（把伞上的屎抖出去）
						CustomShiroCacheManager （implements CacheManager, Destroyable） getCache destroy getShiroCacheManager setShiroCacheManager
						蠄蜍（去）开门，（原来是）（王）嘉文（来了），（他带来了）豆浆，（用）煲（装着），姜（插着）旗（子）（浮在上面），（还有）大枣。（突然），（一块）（沾有）狗屎（的）沙琪玛（掉进煲里）
						JedisShiroCacheManager （implements ShiroCacheManager） getCache destroy getJedisManager setJedisManager
						谢诗琪（在准备发角球的时候）（被）蚊（子）（咬），（用）湿鸡毛（也赶不走蚊子）。（此时）角旗（被人用）大狙（AWP）（打倒），（谢诗琪被吓得赶紧发球）。（却又发现）脚（上）（有）蛇，（一甩），（蛇飞起来咬住她的）睫毛
					JedisManager jedisPool getJedis returnResource getValueByKey deleteByKey saveValueByKey getJedisPool setJedisPool AllSession
					（一把）遮（挂在）门（上），（行驶中的）捷豹（的门上）。（车撞飞一只）曱甴，（它飞进了）（一间）房子，（落在）鸡生肠（上），（鸡生肠用）簸箕（盛着），（旁边还有）鸡锡，（鸡锡上冒起）紫（色的）泡，（曱甴在这些东西上面）屙屎
					JedisShiroCache （implements Cache） REDIS_SHIRO_CACHE DB_INDEX jedisManager name SELF 构造 buildCacheKey （还有一组getter和setter以及接口被实现方法未作记忆：getName、setName、get、put、remove、clear、size、keys、values）
					谢诗琪撒盐（在）鸡（身上），（并且用）绿色棋（子）（摆盘），（完成后随手）丢（烟）头（到）遮（和）袜（子）堆里。（这时候），（浑身是）泥（的）小夫（回来了），狗走（过去迎接），（小夫看着狗没注意到地面），（踩到）白鸡屎
					JedisShiroSessionRepository REDIS_SHIRO_SESSION REDIS_SHIRO_ALL SESSION_VAL_TIME_SPAN DB_INDEX jedisManager saveSession deleteSession getSession getAllSessions buildRedisSessionKey getJedisManager setJedisManager
					（把）结石雪梨（埋进）绿色沙（子里），（然后用）镭射（指着沙堆引诱）鹅（去吃梨）——（其实这个陷阱）——用丝袜（和）（领）tie（绑着）书本（悬挂在沙堆之上）。丢（一个）烟（头）（过去），（就让书本落下来了）。（鹅的）睫毛（受颤），（感受到了危险降临，但来不及了）。（这时），（一只全息）3D狗（跑过去）夹（住）鹅锡（救走了鹅），（带至）避雷（针下），（给）蒜鸡（鹅吃）。（又用）狗屎（吸引一些）蚱蜢（过来给鹅吃）
					ShiroCacheManager getCache destroy（破坏）
					沙琪玛（被）狗啃，（阿）婆（拿一只）环（套住狗）
					VCache （JedisManager J） get set setex getVByMap setVByMap delByMapKey getVByList getLenBySet delSetByKey srandmember setVBySet getSetByKey setVByList getVByList getLenByList delByKey exists returnResource
					
				filter KickoutSession Login Permission Role ShiroFilterUtils SimpleAuth
				（一辆）飞度（在行驶路上遇到一只）企鹅，（它嘴里叼着）蛇，（手持）锣（作为盾牌，并且锣上有）镜（面），（它抛洒混和了）泡沫（的甲）醇 （在）（公）路（上），（车子受滑，撞向一块大）石（并）飞（出公路，扎进河里）游（了起来），（河里有一群）星脯（胸牌有星星的）鹅
				listener CustomSessionListener
				李晨（用）卡（车）（拉着）雪梨
				service ShiroManagerImpl ShiroManager
				（用）蛇皮（和）（用）十蚊（钱）（买来的）烟（草）（包了一支烟，并抽了起来），（不小心）烧（着自己的）毛（了）
				（带回来一条）（用）蛇皮（包住的）石斑鱼，（和）烧馒（头）（一起吃）
					ShiroManagerImpl shiroFilterFactoryBean loadFilterChainDefinitions getFixedAuthRule reCreateFilterChains setShiroFilterFactoryBean
					石斑鱼（在）石缝（屙下）粪便，路飞（在水下拿着）叉（子）（对石斑鱼放）电，（梁）家辉（在船上）屙（了一个）雷，（雷爆炸解决了水下的人），（家辉拿）尤加利（树枝绑住一条）肥肠（开始钓石斑鱼），（此时）（一部）三星（手机）漂（过水面），（三星手机边框纹着）花边
				session CustomSessionManager SessionStatus ShiroSessionRepository
				石山（上），蠄蜍（在捕）蚊，蛇（拖）（一只）（老）鼠（进）地（下），（这时）（一条）（丧）尸（穿着）（衬）衫（从）裂（开的石山里爬出来）
					CustomSessionManager SESSION_STATUS （shiroSessionRepository customShiroSessionDAO 不作记忆） getAllUser getSimplePrincipalCollectionByUserId getSession getSessionBo changeSessionStatus forbidUserById （setShiroSessionRepository setCustomShiroSessionDAO 不作记忆）
					蠄蜍（追逐）蚊（子），沙师弟（一路跟过来，然后不知怎么走了），（这时遇到一个）骑（着）鹅（的）爷（爷），（就跟着爷爷走了），（最后遇到）（李）嘉欣，（她在把）白鸽（放进）白（色）油盎，（沙师弟看了按捺不住），解衫，（上去舔李嘉欣）袈裟（下的）波。（这时）青蛇（咬着）CD，（用CD擦出火花引爆）火药，（火药在）白（色）桉（下）
					SessionStatus onlineStatus isOnlineStatus getOnlineStatus setOnlineStatus
					蛇（把）（老）鼠（拖进）地（洞）（后），（把老鼠埋在）烟丝（里），（用）袈裟（包着），（然后挂在）桉（树）（上的）蓝（色）（螺）丝钉（上）
					ShiroSessionRepository saveSession deleteSession getSession getAllSessions
					十三姨（用）鸡生肠（绑住）鸡（和）鹅，（然后用刷子帮它们）刷身
				token TokenManager SampleRealm ShiroToken
				踢球，（球飞出去），（砸）塌（了）门，（这时），（一辆）三菱（开出来），射（避孕）套（作为反击）
					TokenManager SampleRealm customSessionManager getToken getSession getNickname getUserId getYZM getVal2Session setVal2Session login logout isLogin clearNowUserAuth clearUserAuthByUserId clearUserAuthByUserId
					兔（子）（在）门（上不肯下来），（于是）（开着）三菱（去撞），（撞得一团糟），（一群）蠄蜍（跳了出来），（还追逐着）蚊，（驾驶员的）脚（陷进）桶（里），（桶里满是）沙（和）泥，（脚拔不出来），（唯有从）油盎（倒些）油芝麻（进去润滑一下才能拔出来）。（旁边的）萝（筐）（冒）烟，（海）鸥（四散）。（这时房子主人）袁驰道（劳作回来了），扛（着）犁，扭（着）腰，（赶着）鹅，（还背着）鱿（鱼）（和）鳄（鱼），（身边的）白羊（追逐着）鸭（子）
					SampleRealm （extends AuthorizingRealm） （userService permissionService roleService 我认为这三个service不用记） doGetAuthenticationInfo doGetAuthorizationInfo clearCachedAuthorizationInfo clearCachedAuthorizationInfo
					三菱（在行驶途中遇到一只）鹅（阻挡），（响）铃（也赶不走）。（唯有用）大疆（取些）荷（叶）用（箱）子（装着）（再点起）烟，（鹅被熏到）呕（吐），（跑去一旁）食鱼（了）。（搞定后），（往）锦鲤旗（方向前进），（旗子上空有）（海）鸥（和）燕（子）（盘旋）
					ShiroToken （extends UsernamePasswordToken） 构造 super pswd getPswd setPswd
					鼠兔（争抢一块）归参，（鼠争不过），（用）Ubuntu（呼唤）狗走（过来）烧炮，（最后兔被吓走），（为了报答狗），（鼠给了狗）鸡肾，（鸡肾上面浇了）（蜂）蜜（芝）麻
				CustomShiroSessionDAO （extends AbstractSessionDAO） shiroSessionRepository getShiroSessionRepository setShiroSessionRepository update delete getActiveSessions doCreate doReadSession
				蠄蜍（跳上）（插在）沙（子）（里的一把）刀，（发现了一个）鼹鼠洞，（于是）（摆放一条）金色死鲨鱼（在洞口作为诱饵），（并且在）凹地（里）（布置了）地雷。（有一只）狗屙屎，（幸好没有引爆地雷）。打卡（打开是一个开锁行为），（把）稻（田里的）绿蛇（放出来捉鼹鼠）
	resources shiro_base_auth.ini config.properties jdbc.properties log4j.properties shiro-config.properties mybatis-config.xml spring-cache.xml spring-mvc.xml spring-mybatis.xml spring-shiro.xml spring-timer.xml spring.xml
	紫烟（升起），石碑（后）（躲着）鹅。（把）烟（插到）泥（里），（开始行动）。扛（着）（小）飞（机）（出去），（小飞机）（把）炸弹（投掷在）奔驰（车上）。（一只）箩（筐）（被）火鸡（拖着），（在掩体里按下）（钥）匙扣，（箩筐爆炸），（炸出一堆）菠萝葡萄，抹头（因为飞溅的东西弄脏了头）。雏田（将）戒指按（在）袜子（上），麦（子）爆（炸），（毁了）（河）堤，尸（体）（躺满）路。（旁边的车的）（轮）胎（上插了）羽（毛），屎（黏在）（汽车）玻璃（上）。猹（躲在）桉（树）（上）（看到这一幕）呕（吐了）
		config.properties domain.cdn domain.www
		
		log4j.properties log4j.rootLogger log4j.appender.Console log4j.appender.Console.Target log4j.appender.Console.layout log4j.appender.Console.layout.ConversionPattern
		
		shiro-config.properties session.timeout session.validate.timespan
		
		mybatis-config.xml typeAliases settings setting defaultExecutorType REUSE
		
		spring-cache.xml jedisPoolConfig jedisPool
		
		spring-mvc.xml <context:component-scan> <mvc:annotation-driven> <mvc:resources> <bean>
			
-----------------------------------------------------------------